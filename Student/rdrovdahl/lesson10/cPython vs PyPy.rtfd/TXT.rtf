{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Tahoma;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww12600\viewh7800\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 Lesson10 performance tuning activity\

\b0 \

\b PyPy vs cPython
\b0 \
\
According to the PyPy documentation, PyPy has several advantages over cPython including:\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls1\ilvl0\cf0 {\listtext	\uc0\u8226 	}Increased speed\
{\listtext	\uc0\u8226 	}Less memory usage\
{\listtext	\uc0\u8226 	}cPython compatibility\
{\listtext	\uc0\u8226 	}Stackless mode support for micro-threads\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
Due to the stated advantages of using PyPy over cPython for heavy computational work, I will explore PyPy vs. cPython on some of our earlier code and document the performance differences.  In particular, I\'92ll be comparing the two interpreters while running a double recursive function to compute a value in the Fibonacci series.\
\
The code is as follows:\
\

\f1 def fibonacci(n):\
    '''\
    This function will return the 'n'th value in the fibonacci series.\
    The starting elements in the series are 0, 1.\
    '''\
    if n == 0:\
        return 0\
    if n == 1:\
        return 1\
    else:\
        return fibonacci(n-1) + fibonacci(n-2)
\f0 \
\
The time will be measured using the GNU Time module from the command line.  To make things interesting, I\'92ll be computing the series to the 50th value.  Tests were ran on a 2017 MacBook Pro.  While the function was running, a single processor thread was observed consistently between 99-100% confirming that this function is making heavy use of the processor to compute the value(s).\
\
PyPy did indeed show a marked improvement on this heavy computational program.  Here are the results:\
\

\b cPython
\b0 :\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 {{\NeXTGraphic Pasted Graphic 2.tiff \width12200 \height2620 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\

\b PyPy
\b0 :\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 {{\NeXTGraphic Pasted Graphic 1.tiff \width11220 \height1720 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
As you can see, there is a dramatic difference between the two.  PyPy was 28 times faster than cPython for this particular function.\
\
There are some drawbacks to using PyPy having to do with Python extension support but they claim to work with most libraries.  Based on the results of this testing, it would be worth giving PyPy a look anytime heavy computational work is occurring.\
}